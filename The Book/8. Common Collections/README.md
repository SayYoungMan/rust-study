# 8. Common Collections

- Standard library includes useful data structures called `collections`. They can contain multiple values and they are stored on the heap, meaning that the amount of data doesn't need to be known at compile time.
- `Vector` allows you to store a variable number of values next to each other.
- `String` is a collection of characters.
- `Hash map` allows you to associate a value with a particular key.

## 8.1. String Lists of Values with Vectors

- Vectors can only store values of the same type. They are useful when you have a list of items.

### Creating a New Vector

- Create a new empty vector using `Vec::new` function.
  ```rust
  let v: Vec<i32> = Vec::new();
  ```
- Note that we have to hint the type of its elements using a type annotation. But if you create it with initial values, Rust will infer the type.
- There is also `vec!` macro which will create a new vector:
  ```rust
  let v = vec![1, 2, 3];
  ```

### updating a Vector

- To add elements to a vector, use `push` method: `v.push(5)`;
- To change its value, we have to make the vector mutable too.

### Reading Elements of Vectors

- We can reference a value stored in a vector via indexing (`&v[2]`) or using `get` method (`v.get(2)`).
- When we use `get` method, we get an `Option<&T>` that we can use with `match`.
- There are two ways so you can choose how the program behaves when you try to use an index value outside the range.
  - `[]` method will cause the program to panic. It's best when you want your program to crash.
  - `get` method will return `None` without panicking. You use it if it can happen occasionally under normal circumstances.
- You can't make changes to a vector if you have immutable references to any of its elements.
- This is because vectors put the values next to each other and adding a new element might require allocating new memory and copying the old element to new space. In that case, the reference to first element would point to deallocated memory.

### Iterating over the Values in a Vector

- Use `for` loop to iterate over elements of a vector. Can also iterate over mutable references to each element in a mutable vector to make changes to all elements.
  ```rust
  for i in &mut v {
      *i += 50;
  }
  ```

### Using an Enum to Store Multiple Types

- To store a list of different types, use variants of the same enum type.
  ```rust
  enum SpreadsheetCell {
      Int(i32),
      Float(f64),
      Text(String),
  }
  let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
  ]
  ```
- You must know the exhaustive set of types a program will get at runtime to store in a vector. Otherwise, use trait object instead.

### Dropping a Vector Drops its Elements

- A vector is freed when it goes out of scope. All of its contents are also dropped.
- The borrow checker ensures that any references to contents of a vector are only used while the vector is valid.

## 8.2. Storing UTF-8 Encoded Text with Strings

### What is a String?

- Rust has only one string type in the core language, which is the string slice `str` that is usually seen in its borrowed form `&str`.
- The `String` type, which is provided by Rust's standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.

### Creating a New String

- `String` is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions and capabilities.
- We can convert any type that implements the `Display` trait into String using `to_string` method.
- We can also use `String::from` to create a String from a string literal.

### Updating a String

#### Appending to a String with push_str and push

- `push_str` can be used to append a string slice to a String.
- It takes a string slice because we don't want to take ownership of the parameter.
- `push` method takes a single character as a parameter and adds it to the String.

#### Concatenation with the + Operator or the format! Macro

- We can combine two Strings with `+` operator.
  ```rust
  let s1 = String::from("Hello, ");
  let s2 = String::from("world!");
  let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
  ```
- The reason why s1 is no longer valid and &s2 is used something to do with signature of `add`function that the operator uses:
  ```rust
  fn add(self, s: &str) -> String {}
  ```
- The compiler can coerce the `&String` argument into `&str`. When we call the `add` method, Rust uses a `deref coercion`, which turns `&s2` into `&s2[..]`.
- This implementation is more efficient as it takes ownership of `s1` and copy only the contents of `s2` instead of both strings.
- For more complicated string combining, we can use `format!` macro instead:

  ```rust
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");

  let s = format!("{s1}-{s2}-{s3}");
  ```

- The code generated by the `format!` macro uses references so doesn't take ownership of any of its parameters.

### Indexing into Strings

- Rust does not support indexing syntax with a String.

#### Internal Representation

- A `String` is a wrapper over a `Vec<u8>`.
- Each Unicode scalar value in string takes 2 bytes of storage. Therefore, an index into string's bytes will not always correspond to a valid Unicode scalar value. Therefore, index in this vector would return unexpected result.
- Therefore, prevent this behavior at compile time.

#### Bytes and Scalar Values and Grapheme Clusters! Oh My!

- Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs.
- Indexing to String is expected to take `O(1)` but it isn't possible to guarantee that because Rust would have to walk through the contents to determine how many valid characters there were.

#### Slicing String

- If you really need to use indices to create string slices, Rust asks you to be more specific.
- Rather than indexing using `[]` with a single number, you can use a range to create a string slice.
- If we were to try to slice only part of a character's bytes, Rust would panic at runtime so use string slices with caution.

### Methods for Iterating Over Strings

- For individual Unicode scalar values, use the `chars` method:
  ```rust
  for c in "ะะด".chars() {
      println!("{c}");
  }
  ```
- Alternatively, the `bytes` method returns each raw byte.
